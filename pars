import xml.etree.ElementTree as ET
from pprint import pprint

xml_data = """<Rule>
    <settings>
        <DynamicThresholdCalculation>
            <Key>12345</Key>
            <columns>some_column</columns>
            <enabled>true</enabled>
            <threshold>0.75</threshold>
            <mode>adaptive</mode>
            <extraParam>value</extraParam>
            <nested>
                <subParam>123</subParam>
            </nested>
            <calculations>
                <formula>x + y</formula>
            </calculations>
        </DynamicThresholdCalculation>
    </settings>
</Rule>"""

# Parse and extract
root = ET.fromstring(xml_data)
dynamic_threshold = root.find(".//DynamicThresholdCalculation")

# Convert to dictionary (handles nested elements)
def xml_to_dict(element):
    return {child.tag: xml_to_dict(child) if list(child) else child.text for child in element}

# Validate conditions
if dynamic_threshold is not None:
    key = dynamic_threshold.find("Key")
    columns = dynamic_threshold.find("columns")
    calculations = dynamic_threshold.findall("calculations")

    if key is None or not key.text.strip():
        print("❌ Validation Failed: <Key> tag is missing or empty.")
    elif columns is None:
        print("❌ Validation Failed: <columns> tag is missing.")
    elif len(calculations) != 1:
        print(f"❌ Validation Failed: Expected 1 <calculations> tag, found {len(calculations)}.")
    else:
        print("✅ Validation Passed! Extracted Data:")
        pprint(xml_to_dict(dynamic_threshold))
else:
    print("❌ Tag <DynamicThresholdCalculation> not found.")




import xml.etree.ElementTree as ET

def validate_dynamic_thresholds(xml_data):
    root = ET.fromstring(xml_data)
    dynamic_thresholds = root.find("DynamicThresholdCalculations")

    if dynamic_thresholds is None:
        raise ValueError("Missing <DynamicThresholdCalculations> section")

    # 1. Validate PrimaryKey (account_id should not be null)
    primary_key = dynamic_thresholds.find("PrimaryKey/Key")
    if primary_key is None or not primary_key.text or not primary_key.text.strip():
        raise ValueError("PrimaryKey <Key> cannot be null or empty")

    # 2. Validate at least one <Calculation> tag
    calculations = dynamic_thresholds.findall("Calculation")
    if not calculations:
        raise ValueError("At least one <Calculation> tag is required")

    for calc in calculations:
        # 3. Validate mandatory fields in <



import xmltodict

def extract_dynamic_threshold(xml_data):
    # Convert XML to dictionary
    xml_dict = xmltodict.parse(xml_data)
    
    # Navigate to the DynamicThresholdCalculations part
    dynamic_thresholds = xml_dict.get("Rules", {}).get("DynamicThresholdCalculations", {})
    
    # Store it separately (you can save it to a file or use it as needed)
    return dynamic_thresholds

# Example XML Input
xml_data = """<Rules>
    <DynamicThresholdCalculations>
        <PrimaryKey>
            <Key>account_id</Key>
        </PrimaryKey>
        <Columns>
            <Column name="mean" type="float32"></Column>
            <Column name="std" type="float32"></Column>
        </Columns>
        <Calculation>
            <DatasetId>ds2</DatasetId>
            <Key>account_id</Key>
            <Filters>
                <Filter>
                    <Column>lookback</Column>
                    <Operator>between</Operator>
                    <Value>(2,13)</Value>
                </Filter>
            </Filters>
            <Value>
                <GroupBy>
                    <Column>amount</Column>
                    <Function>mean, std</Function>
                </GroupBy>
            </Value>
        </Calculation>
    </DynamicThresholdCalculations>
</Rules>"""

# Extract the dynamic threshold section
dynamic_threshold_dict = extract_dynamic_threshold(xml_data)

# Print extracted dictionary
import json
print(json.dumps(dynamic_threshold_dict, indent=4))



for col_name, col_type in column_mapping.items():
            if col_name in DYN_CAL_DF.columns:
                # First rename the column if it exists and needs to be renamed
                # Then cast it to the specified type
                if col_type.lower() == "string":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Utf8).alias(col_name))
                elif col_type.lower() in ["int", "integer", "int64"]:
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Int64).alias(col_name))
                elif col_type.lower() == "int32":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Int32).alias(col_name))
                elif col_type.lower() == "int16":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Int16).alias(col_name))
                elif col_type.lower() == "int8":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Int8).alias(col_name))
                elif col_type.lower() == "uint32":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.UInt32).alias(col_name))
                elif col_type.lower() == "uint64":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.UInt64).alias(col_name))
                elif col_type.lower() in ["float", "double", "float64"]:
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Float64).alias(col_name))
                elif col_type.lower() == "float32":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Float32).alias(col_name))
                elif col_type.lower() == "decimal":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Decimal).alias(col_name))
                elif col_type.lower() == "bool" or col_type.lower() == "boolean":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Boolean).alias(col_name))
                elif col_type.lower() == "date":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Date).alias(col_name))
                elif col_type.lower() == "datetime":
                    DYN_CAL_DF = DYN_CAL_DF.with_column(pl.col(col_name).cast(pl.Datetime).alias(col_name))